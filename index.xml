<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jane - A super concise theme for Hugo</title>
    <link>https://mr-house.github.io/</link>
    <description>Recent content on Jane - A super concise theme for Hugo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 19 Dec 2019 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://mr-house.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>关于</title>
      <link>https://mr-house.github.io/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>https://mr-house.github.io/about/</guid>
      
        <description>&lt;p&gt;Hugo is a static site engine written in Go.&lt;/p&gt;
&lt;p&gt;It makes use of a variety of open source projects including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cobra&#34;&gt;Cobra&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/viper&#34;&gt;Viper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/jWalterWeatherman&#34;&gt;J Walter Weatherman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cast&#34;&gt;Cast&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Learn more and contribute on &lt;a href=&#34;https://github.com/gohugoio&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>nginx版本发布年线</title>
      <link>https://mr-house.github.io/post/nginx%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83%E5%8E%86%E5%8F%B2/</link>
      <pubDate>Thu, 19 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://mr-house.github.io/post/nginx%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83%E5%8E%86%E5%8F%B2/</guid>
      
        <description>&lt;h3 id=&#34;heading&#34;&gt;版本发布年线&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;nginx从2002年开始开发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2004年10月4号，nginx发布第一个版本，0.1.0版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2005年，nginx做过一次大的重构， 重构了http反向代理，此后nginx的架构设计没有再发生过大的变动。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2009年发布的0.7.52版本开始支持windows系统。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2011年，nginx1.0版本发布，支持上游keepalive http长连接。同年，nginx商业公司Nginx Plus成立。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2013年，支持websocket、TFO等协议。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2015年，支持thread pool，提供stream四层反向代理，支持reuseport特性，支持httpv2协议。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2016年，支持动态模块。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2018年支持TLSv1.3。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;heading-1&#34;&gt;版本发布特点&lt;/h3&gt;
&lt;p&gt;nginx版本发布有mainline主干版本和stable稳定版本两种。&lt;/p&gt;
&lt;p&gt;通常，单数版本为主线版本（如1.15.12），双数版本为稳定版本（如1.16.0）。&lt;/p&gt;
&lt;p&gt;主干版本会新增很多功能，但这些功能不一定稳定 。&lt;/p&gt;
&lt;p&gt;nginx的版本发布日志通常包括五种类型Feature、Bugfix、Change、Workaround、Security。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Feature表示新增了哪些功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bugfix 表示修复了哪些bug。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Change表示做了哪些小的重构。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Workaround表示一些潜在问题的描述及解决方案。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Security表示一些特性在特定场景下可能会导致比较严重后果，如内存溢出、内存泄漏等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>一条SQL查询语句是怎么执行的</title>
      <link>https://mr-house.github.io/post/1%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E4%B8%80%E6%9D%A1sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84/</link>
      <pubDate>Thu, 19 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://mr-house.github.io/post/1%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E4%B8%80%E6%9D%A1sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84/</guid>
      
        <description>&lt;h2 id=&#34;sql&#34;&gt;基础架构，一条SQL查询语句是怎么执行的&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;MySQL分Server层和存储引擎层。&lt;/li&gt;
&lt;li&gt;Server层包括连接器、查询缓存、分析器、优化器、执行器，涵盖大多数核心服务功能以及所有的内置函数，所有的跨存储引擎的功能都在Server层实现，如存储过程、视图、触发器等。&lt;/li&gt;
&lt;li&gt;存储引擎层负责数据的存储和提取，采用插件机制，支持InnoDB、MyISAM、Memory等多个存储引擎。MySQL从5.5.5版本开始，默认为InnoDB引擎。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;heading&#34;&gt;连接器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;连接器负责跟客户端建立连接、获取权限、维护和管理连接，命令如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;  mysql -h$ip -P$port -u$user -p$password
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;用户名、密码认证通过后，连接器会到权限表里读取当前用户拥有的权限，之后，这个连接里面的权限判断逻辑都依赖于此时读到的权限，因此当权限发生变更时，并不会影响已经存在的连接，只对后面新建立的连接生效。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;show processlist&lt;/code&gt;命令可以查看当前建立的连接，其中&lt;em&gt;&lt;strong&gt;Command&lt;/strong&gt;&lt;/em&gt;列显示&lt;em&gt;&lt;strong&gt;Sleep&lt;/strong&gt;&lt;/em&gt;的行为空闲连接。&lt;/li&gt;
&lt;li&gt;客户端如果太长时间没动静，连接就会断开，默认为8小时，由&lt;code&gt;wait_timeout&lt;/code&gt;参数控制。&lt;/li&gt;
&lt;li&gt;数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。但是长连接会特别耗内存，因为MySQL在执行过程中临时使用的内存是管理在连接对象中的，这些内存只有在连接断开的时候才会释放，因此长期使用长连接可能会导致OOM，表现为MySQL异常重启。这个问题的解决方案有两种，&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。&lt;/li&gt;
&lt;li&gt;如果用的是 MySQL 5.7 或更高的版本，可以在每次执行一个比较大的操作后，通过执行&lt;code&gt;mysql_reset_connection&lt;/code&gt;来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;heading-1&#34;&gt;查询缓存&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;之前执行过的查询语句及其结果可能（为什么是可能？）会以key-value的形式缓存在内存中。key 是查询的语句，value 是查询的结果。MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。***但是大多数情况下不建议使用查询缓存，因为查询缓存往往弊大于利。***查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此除非你的业务就是一张静态表，很长时间才会更新一次，这种场景才适合使用查询缓存。&lt;/li&gt;
&lt;li&gt;MySQL也提供了按需使用查询缓存的功能，可以将参数&lt;em&gt;&lt;strong&gt;query_cache_type&lt;/strong&gt;&lt;/em&gt;设置成&lt;em&gt;&lt;strong&gt;DEMAND&lt;/strong&gt;&lt;/em&gt;，这样对于默认的SQL语句都不使用查询缓存，对于需要使用查询缓存的语句，可以通过&lt;em&gt;&lt;strong&gt;SQL_CACHE&lt;/strong&gt;&lt;/em&gt;显式指定，写法如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;select SQL_CACHE * from T where id = 10;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;MySQL 8.0 版本直接将查询缓存的整块功能删掉了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;heading-2&#34;&gt;分析器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;分析器会先做词法分析，再做语法分析。&lt;/li&gt;
&lt;li&gt;词法分析器会识别关键字、表名、列名，例如通过&lt;em&gt;&lt;strong&gt;select&lt;/strong&gt;&lt;/em&gt;关键字判断是否是查询语句。&lt;/li&gt;
&lt;li&gt;根据词法分析器的结果，语法分析器会根据语法规则，判断要执行的SQL语句是否满足MySQL的语法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;heading-3&#34;&gt;优化器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;优化器会根据执行效率，选择要使用的索引（多索引的情况），决定表连接顺序（多表连接的情况）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;heading-4&#34;&gt;执行器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;执行器在执行查询之前先进行权限验证（在工程实现上（？），如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 &lt;em&gt;&lt;strong&gt;precheck&lt;/strong&gt;&lt;/em&gt;验证权限（查询缓存的key是优化后的sql还是优化前的sql？））。&lt;/li&gt;
&lt;li&gt;慢查询日志中的*&lt;strong&gt;rows_examined&lt;/strong&gt;字段表示这个语句执行过程中扫描了多少行。在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
  </channel>
</rss>
